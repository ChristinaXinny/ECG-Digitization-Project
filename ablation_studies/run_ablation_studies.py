"""Main script to run all ablation studies.

This script runs comprehensive ablation studies to evaluate the contribution
of each component in the ECG digitization pipeline.
"""

import os
import time
import argparse
from datetime import datetime

# Add parent directory to path
import sys
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)

from ablation_studies.backbone_ablation import BackboneAblation
from ablation_studies.loss_ablation import LossAblation
from ablation_studies.module_ablation import ModuleAblation
from ablation_studies.data_augmentation_ablation import DataAugmentationAblation


def print_banner():
    """Print a nice banner for the ablation studies."""
    banner = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                ECG DIGITIZATION - ABLATION STUDIES               â•‘
â•‘                                                              â•‘
â•‘  Comprehensive evaluation of model components and design choices â•‘
â•‘              to prove the necessity of each module.             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    """
    print(banner)


def create_results_summary():
    """Create a summary report combining all ablation study results."""
    results_dir = "./ablation_studies/results"

    summary_file = os.path.join(results_dir, "ablation_summary.md")

    summary_content = f"""# ECG Digitization Ablation Studies - Summary Report

Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Overview

This document summarizes the findings from comprehensive ablation studies conducted
to evaluate the contribution of different components in the ECG digitization pipeline.

## Available Studies

1. **Backbone Ablation** - Tests different encoder architectures
2. **Loss Function Ablation** - Evaluates various loss configurations
3. **Module Ablation** - Analyzes individual model components
4. **Data Augmentation Ablation** - Tests different augmentation strategies

## Key Findings

###  Performance Impact Analysis

| Component Category | Best Performance | Most Efficient | Fastest Training |
|-------------------|------------------|-----------------|------------------|
| Backbone | [See backbone_detailed_analysis.md] | [See backbone_detailed_analysis.md] | [See backbone_detailed_analysis.md] |
| Loss Function | [See loss_ablation_results.csv] | [See loss_ablation_results.csv] | [See loss_ablation_results.csv] |
| Model Modules | [See module_ablation_summary.md] | [See module_ablation_summary.md] | [See module_ablation_summary.md] |
| Data Augmentation | [See augmentation_comparison.png] | [See augmentation_comparison.png] | [See augmentation_comparison.png] |

### ğŸ” Component Necessity Evidence

The ablation studies provide quantitative evidence for the necessity of each component:

1. **Decoder Architecture**: Essential for upsampling features to target resolution
2. **Multi-task Heads**: Both marker and orientation heads contribute significantly
3. **Attention Mechanisms**: Improved performance for complex ECG patterns
4. **Appropriate Data Augmentation**: Crucial for generalization and robustness
5. **Loss Function Balance**: Proper weighting between tasks is critical

###  Recommendations

Based on the ablation study results:

#### **For Maximum Accuracy**
- Use the backbone architecture with highest validation performance
- Enable all proven beneficial modules
- Use balanced loss functions
- Apply appropriate data augmentation

#### **For Resource-Constrained Environments**
- Choose efficient backbone (e.g., MobileNet or EfficientNet)
- Reduce model complexity while maintaining core functionality
- Optimize data augmentation for training efficiency

#### **For Rapid Prototyping**
- Use lightweight configurations
- Reduce training epochs with strong augmentation
- Focus on core functionality

## Detailed Reports

- [Backbone Analysis](backbone_detailed_analysis.md) - Comprehensive backbone comparison
- [Loss Function Results](loss_ablation_results.csv) - Raw loss function performance data
- [Module Analysis](module_impact.png) - Component contribution visualization
- [Augmentation Analysis](augmentation_comparison.png) - Data augmentation impact

## Conclusion

The ablation studies demonstrate that each component in the ECG digitization pipeline
contributes meaningfully to the overall performance. The modular architecture allows for
flexible optimization based on specific requirements and constraints.

---

*This report was automatically generated by the ECG Digitization Ablation Studies framework.*
"""

    with open(summary_file, 'w') as f:
        f.write(summary_content)

    print(f"Summary report created: {summary_file}")


def run_single_study(study_name, study_class):
    """Run a single ablation study."""
    print(f"\n{'='*60}")
    print(f"Running {study_name} Ablation Study")
    print(f"{'='*60}")

    start_time = time.time()

    try:
        # Initialize and run the study
        ablation = study_class()
        ablation.run_study()

        # Create additional visualizations if available
        if hasattr(ablation, 'create_comparison_plots'):
            ablation.create_comparison_plots()
        if hasattr(ablation, 'generate_detailed_report'):
            ablation.generate_detailed_report()

        end_time = time.time()
        duration = end_time - start_time

        print(f"\n[OK] {study_name} study completed successfully!")
        print(f"   Duration: {duration/60:.1f} minutes")
        print(f"   Results saved to: {ablation.output_dir}")

    except Exception as e:
        print(f"\n {study_name} study failed: {e}")
        import traceback
        traceback.print_exc()
        return False

    return True


def run_all_studies(selected_studies=None):
    """Run all or selected ablation studies."""
    print_banner()

    # Define available studies
    available_studies = {
        'backbone': ('Backbone', BackboneAblation),
        'loss': ('Loss Function', LossAblation),
        'module': ('Module', ModuleAblation),
        'augmentation': ('Data Augmentation', DataAugmentationAblation)
    }

    # Determine which studies to run
    if selected_studies is None:
        studies_to_run = list(available_studies.keys())
    else:
        studies_to_run = [s for s in selected_studies if s in available_studies]
        missing = [s for s in selected_studies if s not in available_studies]
        if missing:
            print(f"  Unknown studies: {missing}")
            print(f"Available studies: {list(available_studies.keys())}")

    if not studies_to_run:
        print(" No studies selected for execution")
        return

    print(f"Studies to run: {', '.join([available_studies[s][0] for s in studies_to_run])}")
    print(f"Total studies: {len(studies_to_run)}")

    # Track results
    successful_studies = []
    failed_studies = []

    overall_start_time = time.time()

    # Run each study
    for study_key in studies_to_run:
        study_name, study_class = available_studies[study_key]
        success = run_single_study(study_name, study_class)

        if success:
            successful_studies.append(study_name)
        else:
            failed_studies.append(study_name)

    overall_end_time = time.time()
    total_duration = overall_end_time - overall_start_time

    # Final summary
    print(f"\n{'='*60}")
    print(f"ABLATION STUDIES - FINAL SUMMARY")
    print(f"{'='*60}")
    print(f"Total Duration: {total_duration/3600:.1f} hours")
    print(f"Studies Completed: {len(successful_studies)}/{len(studies_to_run)}")

    if successful_studies:
        print(f"[OK] Successful: {', '.join(successful_studies)}")
    if failed_studies:
        print(f" Failed: {', '.join(failed_studies)}")

    # Create summary report
    create_results_summary()

    print(f"\n All results and visualizations saved to: ./ablation_studies/results/")
    print(f"ğŸ“„ Summary report: ./ablation_studies/results/ablation_summary.md")

    return len(failed_studies) == 0


def main():
    """Main function to run ablation studies."""
    parser = argparse.ArgumentParser(
        description="Run ECG Digitization Ablation Studies",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python run_ablation_studies.py                           # Run all studies
  python run_ablation_studies.py --studies backbone loss   # Run specific studies
  python run_ablation_studies.py --studies module --verbose    # Run single study with verbose output
        """
    )

    parser.add_argument(
        '--studies',
        nargs='+',
        choices=['backbone', 'loss', 'module', 'augmentation'],
        help='Specific studies to run (default: all)'
    )

    parser.add_argument(
        '--verbose',
        action='store_true',
        help='Enable verbose output'
    )

    args = parser.parse_args()

    # Set verbose mode if requested
    if args.verbose:
        import logging
        logging.basicConfig(level=logging.INFO)
        print("Verbose mode enabled")

    # Run the studies
    success = run_all_studies(args.studies)

    if success:
        print("\n All ablation studies completed successfully!")
    else:
        print("\n  Some studies failed. Check the logs above for details.")
        return 1

    return 0


if __name__ == "__main__":
    exit(main())